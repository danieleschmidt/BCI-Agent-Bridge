"""
Steady-State Visual Evoked Potential (SSVEP) decoder for BCI selection.
"""

import numpy as np
from scipy import signal
from scipy.stats import pearsonr
import logging
from typing import Dict, Any, Optional, List, Tuple

from .base import BaseDecoder


class SSVEPDecoder(BaseDecoder):
    """
    SSVEP decoder using canonical correlation analysis and frequency domain methods.
    
    Detects steady-state visual evoked potentials generated by flickering stimuli
    at specific frequencies for high-speed BCI selection interfaces.
    """
    
    def __init__(
        self, 
        channels: int = 8, 
        sampling_rate: int = 250,
        frequencies: List[float] = None,
        window_length: float = 4.0,
        n_harmonics: int = 3
    ):
        super().__init__(channels, sampling_rate)
        
        self.logger = logging.getLogger(__name__)
        
        # SSVEP parameters
        self.frequencies = frequencies or [6.0, 7.5, 8.57, 10.0]  # Hz
        self.window_length = window_length  # seconds
        self.n_harmonics = n_harmonics
        
        # Frequency detection parameters
        self.min_frequency = 5.0   # Hz
        self.max_frequency = 15.0  # Hz
        self.frequency_resolution = 0.1  # Hz
        
        # Reference signals for CCA
        self.reference_signals = {}
        self._generate_reference_signals()
        
        # Frequency-to-command mapping
        self.freq_to_command = {
            6.0: "Option 1 selected",
            7.5: "Option 2 selected", 
            8.57: "Option 3 selected",
            10.0: "Option 4 selected"
        }
        
        # Calibration data
        self.frequency_templates = {}
        self.snr_thresholds = {}
        
        self.logger.info(f"SSVEP decoder initialized with frequencies: {self.frequencies}")
    
    def _generate_reference_signals(self) -> None:
        """Generate reference signals for canonical correlation analysis."""
        n_samples = int(self.window_length * self.sampling_rate)
        t = np.linspace(0, self.window_length, n_samples, endpoint=False)
        
        for freq in self.frequencies:
            # Generate sine and cosine references for fundamental and harmonics
            references = []
            
            for harmonic in range(1, self.n_harmonics + 1):
                harm_freq = freq * harmonic
                references.append(np.sin(2 * np.pi * harm_freq * t))
                references.append(np.cos(2 * np.pi * harm_freq * t))
            
            self.reference_signals[freq] = np.array(references)
    
    def extract_features(self, data: np.ndarray) -> np.ndarray:
        """
        Extract SSVEP features from EEG data.
        
        Args:
            data: EEG data (channels x samples)
            
        Returns:
            Feature vector for frequency detection
        """
        if data.size == 0:
            return np.array([])
        
        # Ensure correct shape
        if data.ndim == 1:
            data = data.reshape(1, -1)
        
        # Extract SSVEP time window
        ssvep_data = self._extract_ssvep_window(data)
        
        if ssvep_data.size == 0:
            return np.array([])
        
        features = []
        
        # 1. Power spectral density features
        psd_features = self._extract_psd_features(ssvep_data)
        features.extend(psd_features)
        
        # 2. Canonical correlation features
        cca_features = self._extract_cca_features(ssvep_data)
        features.extend(cca_features)
        
        # 3. Signal-to-noise ratio features
        snr_features = self._extract_snr_features(ssvep_data)
        features.extend(snr_features)
        
        # 4. Phase coherence features
        phase_features = self._extract_phase_features(ssvep_data)
        features.extend(phase_features)
        
        return np.array(features)
    
    def _extract_ssvep_window(self, data: np.ndarray) -> np.ndarray:
        """Extract SSVEP analysis window."""
        window_samples = int(self.window_length * self.sampling_rate)
        
        if data.shape[1] < window_samples:
            # Pad with zeros if needed
            padding = window_samples - data.shape[1]
            data = np.pad(data, ((0, 0), (0, padding)), mode='constant')
        elif data.shape[1] > window_samples:
            # Take the last window_samples
            data = data[:, -window_samples:]
        
        return data
    
    def _extract_psd_features(self, data: np.ndarray) -> List[float]:
        """Extract power spectral density features."""
        features = []
        
        try:
            # Compute PSD for each channel
            for ch in range(data.shape[0]):
                freqs, psd = signal.welch(
                    data[ch], 
                    fs=self.sampling_rate,
                    nperseg=min(256, data.shape[1]//2),
                    noverlap=None
                )
                
                # Extract power at target frequencies
                for target_freq in self.frequencies:
                    # Find closest frequency bin
                    freq_idx = np.argmin(np.abs(freqs - target_freq))
                    target_power = psd[freq_idx]
                    
                    # Also check harmonics
                    harmonic_power = 0
                    for harmonic in range(2, self.n_harmonics + 1):
                        harm_freq = target_freq * harmonic
                        if harm_freq < freqs[-1]:
                            harm_idx = np.argmin(np.abs(freqs - harm_freq))
                            harmonic_power += psd[harm_idx]
                    
                    features.extend([
                        np.log(target_power + 1e-10),
                        np.log(harmonic_power + 1e-10)
                    ])
        
        except Exception as e:
            self.logger.warning(f"PSD feature extraction failed: {e}")
        
        return features
    
    def _extract_cca_features(self, data: np.ndarray) -> List[float]:
        """Extract canonical correlation analysis features."""
        features = []
        
        try:
            for target_freq in self.frequencies:
                if target_freq in self.reference_signals:
                    # Get reference signals
                    references = self.reference_signals[target_freq]
                    
                    # Ensure same length
                    min_length = min(data.shape[1], references.shape[1])
                    data_windowed = data[:, :min_length]
                    ref_windowed = references[:, :min_length]
                    
                    # Compute CCA coefficient
                    cca_coeff = self._compute_cca_coefficient(data_windowed, ref_windowed)
                    features.append(cca_coeff)
                else:
                    features.append(0.0)
        
        except Exception as e:
            self.logger.warning(f"CCA feature extraction failed: {e}")
            features.extend([0.0] * len(self.frequencies))
        
        return features
    
    def _compute_cca_coefficient(self, X: np.ndarray, Y: np.ndarray) -> float:
        """Compute canonical correlation coefficient."""
        try:
            # Simple correlation-based approximation to CCA
            # In practice, would use more sophisticated CCA implementation
            
            # Take first channel of X and first reference of Y
            if X.shape[0] > 0 and Y.shape[0] > 0:
                corr, _ = pearsonr(X[0], Y[0])
                return abs(corr) if not np.isnan(corr) else 0.0
            
            return 0.0
            
        except Exception:
            return 0.0
    
    def _extract_snr_features(self, data: np.ndarray) -> List[float]:
        """Extract signal-to-noise ratio features."""
        features = []
        
        try:
            for ch in range(data.shape[0]):
                channel_data = data[ch]
                
                # Compute SNR for each target frequency
                for target_freq in self.frequencies:
                    snr = self._compute_frequency_snr(channel_data, target_freq)
                    features.append(snr)
        
        except Exception as e:
            self.logger.warning(f"SNR feature extraction failed: {e}")
        
        return features
    
    def _compute_frequency_snr(self, signal_data: np.ndarray, target_freq: float) -> float:
        """Compute SNR at target frequency."""
        try:
            freqs, psd = signal.welch(
                signal_data,
                fs=self.sampling_rate,
                nperseg=min(256, len(signal_data)//2)
            )
            
            # Find target frequency bin
            target_idx = np.argmin(np.abs(freqs - target_freq))
            target_power = psd[target_idx]
            
            # Estimate noise power from neighboring frequencies
            neighbor_range = 5  # bins
            start_idx = max(0, target_idx - neighbor_range)
            end_idx = min(len(psd), target_idx + neighbor_range + 1)
            
            # Exclude target bin from noise estimation
            noise_indices = np.concatenate([
                np.arange(start_idx, target_idx),
                np.arange(target_idx + 1, end_idx)
            ])
            
            if len(noise_indices) > 0:
                noise_power = np.mean(psd[noise_indices])
                snr = 10 * np.log10(target_power / (noise_power + 1e-10))
                return snr
            
            return 0.0
            
        except Exception:
            return 0.0
    
    def _extract_phase_features(self, data: np.ndarray) -> List[float]:
        """Extract phase coherence features."""
        features = []
        
        try:
            for target_freq in self.frequencies:
                # Compute phase coherence across channels
                phases = []
                
                for ch in range(data.shape[0]):
                    # Extract phase at target frequency using Hilbert transform
                    analytic_signal = signal.hilbert(data[ch])
                    instantaneous_phase = np.angle(analytic_signal)
                    
                    # Average phase over time window
                    mean_phase = np.mean(instantaneous_phase)
                    phases.append(mean_phase)
                
                # Compute phase coherence (consistency across channels)
                if len(phases) > 1:
                    phase_coherence = np.abs(np.mean(np.exp(1j * np.array(phases))))
                    features.append(phase_coherence)
                else:
                    features.append(0.0)
        
        except Exception as e:
            self.logger.warning(f"Phase feature extraction failed: {e}")
        
        return features
    
    def predict(self, features: np.ndarray) -> int:
        """
        Predict attended frequency from SSVEP features.
        
        Args:
            features: Extracted feature vector
            
        Returns:
            Index of detected frequency (0-3 for 4 frequencies)
        """
        if features.size == 0:
            self.last_confidence = 0.0
            return 0
        
        try:
            # Extract CCA features (assuming they're in the feature vector)
            n_freqs = len(self.frequencies)
            
            # Find CCA features in the feature vector
            # Assuming CCA features start after PSD features
            psd_features_per_freq = 2  # power + harmonic power
            psd_feature_count = data.shape[0] * n_freqs * psd_features_per_freq
            
            if len(features) > psd_feature_count:
                cca_start = psd_feature_count
                cca_features = features[cca_start:cca_start + n_freqs]
                
                # Find frequency with highest CCA coefficient
                if len(cca_features) >= n_freqs:
                    best_freq_idx = np.argmax(cca_features)
                    self.last_confidence = cca_features[best_freq_idx]
                    self.last_prediction = best_freq_idx
                    
                    return int(best_freq_idx)
            
            # Fallback: use all features to make decision
            # Simple approach: divide features into groups per frequency
            features_per_freq = len(features) // n_freqs
            if features_per_freq > 0:
                freq_scores = []
                for i in range(n_freqs):
                    start_idx = i * features_per_freq
                    end_idx = (i + 1) * features_per_freq
                    freq_features = features[start_idx:end_idx]
                    score = np.mean(freq_features)  # Simple average
                    freq_scores.append(score)
                
                best_freq_idx = np.argmax(freq_scores)
                self.last_confidence = freq_scores[best_freq_idx] / (np.sum(freq_scores) + 1e-10)
                self.last_prediction = best_freq_idx
                
                return int(best_freq_idx)
            
        except Exception as e:
            self.logger.error(f"SSVEP prediction failed: {e}")
        
        # Random fallback
        self.last_confidence = 0.25  # Random chance for 4 frequencies
        prediction = np.random.choice(len(self.frequencies))
        return prediction
    
    def calibrate(self, calibration_data: np.ndarray, labels: Optional[np.ndarray] = None) -> None:
        """
        Calibrate SSVEP decoder with training data.
        
        Args:
            calibration_data: EEG trials during SSVEP stimulation
            labels: Frequency labels for each trial
        """
        self.logger.info("Starting SSVEP calibration...")
        
        if calibration_data.size == 0:
            self.logger.warning("Empty calibration data")
            return
        
        if labels is None:
            labels = self._generate_simulation_labels(calibration_data.shape[0])
        
        try:
            # Build frequency templates
            for freq_idx, freq in enumerate(self.frequencies):
                freq_trials = calibration_data[labels == freq_idx]
                
                if len(freq_trials) > 0:
                    # Average trials for this frequency
                    template = np.mean(freq_trails, axis=0)
                    self.frequency_templates[freq] = template
                    
                    # Compute SNR threshold
                    snr_values = []
                    for trial in freq_trials:
                        features = self.extract_features(trial)
                        if len(features) > 0:
                            # Extract SNR features (assuming they're in the feature vector)
                            snr_features = self._extract_snr_features(trial)
                            if len(snr_features) > 0:
                                snr_values.append(np.max(snr_features))
                    
                    if snr_values:
                        self.snr_thresholds[freq] = np.mean(snr_values) * 0.7  # 70% of mean
                    else:
                        self.snr_thresholds[freq] = 3.0  # Default 3 dB
            
            self.is_calibrated = True
            self.logger.info(f"SSVEP calibration completed for {len(self.frequency_templates)} frequencies")
            
        except Exception as e:
            self.logger.error(f"SSVEP calibration failed: {e}")
            self.is_calibrated = False
    
    def _generate_simulation_labels(self, n_trials: int) -> np.ndarray:
        """Generate simulated frequency labels."""
        return np.random.choice(len(self.frequencies), n_trials)
    
    def decode_frequency(
        self, 
        data: np.ndarray, 
        method: str = "canonical_correlation"
    ) -> float:
        """
        Decode attended frequency using specified method.
        
        Args:
            data: EEG data for analysis
            method: Detection method ('canonical_correlation', 'psd', 'template_matching')
            
        Returns:
            Detected frequency in Hz
        """
        if method == "canonical_correlation":
            return self._decode_frequency_cca(data)
        elif method == "psd":
            return self._decode_frequency_psd(data)
        elif method == "template_matching":
            return self._decode_frequency_template(data)
        else:
            self.logger.warning(f"Unknown method: {method}, using CCA")
            return self._decode_frequency_cca(data)
    
    def _decode_frequency_cca(self, data: np.ndarray) -> float:
        """Decode frequency using canonical correlation analysis."""
        features = self.extract_features(data)
        freq_idx = self.predict(features)
        return self.frequencies[freq_idx] if freq_idx < len(self.frequencies) else 0.0
    
    def _decode_frequency_psd(self, data: np.ndarray) -> float:
        """Decode frequency using power spectral density analysis."""
        try:
            # Average across channels
            avg_signal = np.mean(data, axis=0)
            
            # Compute PSD
            freqs, psd = signal.welch(
                avg_signal,
                fs=self.sampling_rate,
                nperseg=min(256, len(avg_signal)//2)
            )
            
            # Find peak in SSVEP frequency range
            freq_mask = (freqs >= self.min_frequency) & (freqs <= self.max_frequency)
            masked_psd = psd[freq_mask]
            masked_freqs = freqs[freq_mask]
            
            if len(masked_psd) > 0:
                peak_idx = np.argmax(masked_psd)
                detected_freq = masked_freqs[peak_idx]
                
                # Find closest target frequency
                closest_idx = np.argmin(np.abs(np.array(self.frequencies) - detected_freq))
                return self.frequencies[closest_idx]
            
        except Exception as e:
            self.logger.error(f"PSD frequency detection failed: {e}")
        
        return self.frequencies[0]  # Default
    
    def _decode_frequency_template(self, data: np.ndarray) -> float:
        """Decode frequency using template matching."""
        if not self.frequency_templates:
            return self._decode_frequency_cca(data)
        
        try:
            # Extract SSVEP window
            ssvep_data = self._extract_ssvep_window(data)
            
            # Compare with templates
            correlations = {}
            for freq, template in self.frequency_templates.items():
                if template.shape == ssvep_data.shape:
                    # Compute correlation
                    correlation = np.corrcoef(
                        ssvep_data.flatten(),
                        template.flatten()
                    )[0, 1]
                    correlations[freq] = correlation if not np.isnan(correlation) else 0.0
            
            if correlations:
                best_freq = max(correlations.keys(), key=lambda k: correlations[k])
                return best_freq
                
        except Exception as e:
            self.logger.error(f"Template matching failed: {e}")
        
        return self.frequencies[0]  # Default
    
    def get_ssvep_characteristics(self) -> Dict[str, Any]:
        """Get SSVEP-specific characteristics."""
        return {
            "frequencies": self.frequencies,
            "window_length": self.window_length,
            "n_harmonics": self.n_harmonics,
            "frequency_range": (self.min_frequency, self.max_frequency),
            "freq_to_command": self.freq_to_command,
            "templates_available": list(self.frequency_templates.keys()),
            "snr_thresholds": self.snr_thresholds
        }
    
    def start_stimulation(self) -> None:
        """Start SSVEP stimulation (placeholder for actual implementation)."""
        self.logger.info("SSVEP stimulation started")
        # In real implementation, this would control visual stimuli
    
    def stop_stimulation(self) -> None:
        """Stop SSVEP stimulation."""
        self.logger.info("SSVEP stimulation stopped")
    
    def get_frequency_command(self, frequency: float) -> str:
        """Get command associated with frequency."""
        return self.freq_to_command.get(frequency, f"Frequency {frequency} Hz selected")